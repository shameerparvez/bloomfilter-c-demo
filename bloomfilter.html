<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataLite - Bloom Filter Membership Checker</title>
    <!-- Load Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* slate-900 */
            color: #cbd5e1; /* slate-300 */
        }
        .card {
            background-color: #1e293b; /* slate-800 */
            border-radius: 0.75rem; /* rounded-xl */
            border: 1px solid #334155; /* slate-700 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem; /* rounded-lg */
            font-weight: 500;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }
        .btn-primary {
            background-color: #2563eb; /* blue-600 */
            color: white;
        }
        .btn-primary:hover {
            background-color: #1d4ed8; /* blue-700 */
        }
        .btn-primary:disabled {
            background-color: #334155; /* slate-700 */
            color: #64748b; /* slate-500 */
            cursor: not-allowed;
        }
        .input-field {
            width: 100%;
            background-color: #0f172a; /* slate-900 */
            border: 1px solid #334155; /* slate-700 */
            color: #e2e8f0; /* slate-200 */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 0.75rem 1rem;
        }
        .input-field:focus {
            outline: 2px solid #2563eb; /* blue-600 */
            border-color: #2563eb;
        }
        /* Style for the file input button */
        input[type="file"]::file-selector-button {
            @apply btn btn-primary;
            margin-right: 1rem;
            border: none;
        }
        input[type="file"]::file-selector-button:hover {
             @apply btn btn-primary;
            background-color: #1d4ed8; /* blue-700 */
        }
        
        /* Visualization styles */
        .bit-array {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(10px, 1fr));
            gap: 2px;
        }
        .bit {
            width: 10px;
            height: 10px;
            background-color: #334155; /* slate-700 */
            border-radius: 2px;
            transition: background-color 0.3s;
        }
        .bit.on {
            background-color: #10b981; /* emerald-500 */
            box-shadow: 0 0 5px #10b981;
        }
        .bit.highlight {
            background-color: #f59e0b; /* amber-500 */
            box-shadow: 0 0 5px #f59e0b;
            transform: scale(1.2);
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto space-y-8">
        
        <!-- Header -->
        <header class="text-center">
            <h1 class="text-4xl font-bold text-white">DataLite âš¡</h1>
            <p class="text-xl text-slate-400 mt-2">Client-Side Big Data Query Optimizer</p>
        </header>

        <!-- Main Tool -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <!-- Left Column: Setup & Query -->
            <div class="lg:col-span-2 space-y-6">
                
                <!-- Step 1: Upload & Build -->
                <div class="card p-6 space-y-4">
                    <h2 class="text-2xl font-semibold text-white">1. Build Filter</h2>
                    <p class="text-slate-400">Upload a CSV file and select the column you want to index. All processing happens in your browser.</p>
                    
                    <div>
                        <label for="fileUpload" class="block text-sm font-medium text-slate-300 mb-2">Upload CSV File</label>
                        <input type="file" id="fileUpload" accept=".csv" class="input-field file:border-none file:outline-none">
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="columnSelect" class="block text-sm font-medium text-slate-300 mb-2">Select Column</label>
                            <select id="columnSelect" class="input-field" disabled>
                                <option>Upload a file first</option>
                            </select>
                        </div>
                        <div>
                            <label for="buildButton" class="block text-sm font-medium text-transparent mb-2">Build</label>
                            <button id="buildButton" class="btn btn-primary w-full" disabled>
                                Build Bloom Filter
                            </button>
                        </div>
                    </div>
                    <div id="loadingIndicator" class="hidden items-center space-x-2 text-blue-400">
                        <svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <span>Processing... This may take a moment for large files.</span>
                    </div>
                </div>

                <!-- Step 2: Query -->
                <div id="querySection" class="card p-6 space-y-4 opacity-50 pointer-events-none">
                    <h2 class="text-2xl font-semibold text-white">2. Query</h2>
                    <p class="text-slate-400">Check if an item exists in your dataset. The Bloom filter gives an instant probabilistic answer.</p>
                    <div>
                        <label for="queryInput" class="block text-sm font-medium text-slate-300 mb-2">Item to check (e.g., email, ID)</label>
                        <div class="flex space-x-3">
                            <input type="text" id="queryInput" placeholder="test@example.com" class="input-field">
                            <button id="queryButton" class="btn btn-primary">Check</button>
                        </div>
                    </div>
                </div>

                <!-- Step 3: Results & Performance -->
                <div id="resultsSection" class="card p-6 hidden">
                    <h2 class="text-2xl font-semibold text-white">3. Results</h2>
                    
                    <!-- Query Result Message -->
                    <div id="queryResultMsg" class="text-lg p-4 rounded-lg my-4"></div>

                    <h3 class="text-lg font-semibold text-white mt-4 mb-2">Performance Comparison</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="bg-slate-900 p-4 rounded-lg">
                            <p class="text-sm text-slate-400">Bloom Filter Check</p>
                            <p id="bloomTime" class="text-2xl font-bold text-emerald-400">-- ms</p>
                        </div>
                        <div class="bg-slate-900 p-4 rounded-lg">
                            <p class="text-sm text-slate-400">Traditional Linear Search</p>
                            <p id="linearTime" class="text-2xl font-bold text-red-400">-- ms</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right Column: Stats & Visualization -->
            <div class="lg:col-span-1 space-y-6">
                <!-- Stats Card -->
                <div class="card p-6 space-y-3">
                    <h2 class="text-2xl font-semibold text-white">Filter Statistics</h2>
                    <div class="flex justify-between">
                        <span class="text-slate-400">Items in Set (n)</span>
                        <span id="statItems" class="font-medium text-white">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-slate-400">Filter Size (m bits)</span>
                        <span id="statSize" class="font-medium text-white">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-slate-400">Hash Functions (k)</span>
                        <span id="statHashes" class="font-medium text-white">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-slate-400">Est. False Positive %</span>
                        <span id="statFPR" class="font-medium text-white">0%</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-slate-400">Filter Memory</span>
                        <span id="statMemory" class="font-medium text-white">0 KB</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-slate-400">Original Data Memory</span>
                        <span id="statOriginalMemory" class="font-medium text-white">0 KB</span>
                    </div>
                </div>

                <!-- Visualization Card -->
                <div class="card p-6">
                    <h2 class="text-2xl font-semibold text-white">Live Visualization</h2>
                    <p class="text-slate-400 text-sm mb-4">A sample of the bit array (first 400 bits). Watch bits light up as the filter is built.</p>
                    <div id="bitArrayViz" class="bit-array">
                        <!-- Bits will be dynamically generated here -->
                    </div>
                </div>
            </div>

        </div>
        
        <!-- Educational Section -->
        <div class="card p-6 mt-8">
            <h2 class="text-2xl font-semibold text-white">What is a Bloom Filter?</h2>
            <p class="text-slate-400 mt-2">A Bloom filter is a space-efficient data structure that's used to test whether an element is a member of a set. It's incredibly fast and uses very little memory.</p>
            <ul class="list-disc list-inside text-slate-400 mt-4 space-y-1">
                <li><strong class="text-emerald-400">"Definitely NOT present"</strong>: If the filter says an item is not in the set, it is 100% correct.</li>
                <li><strong class="text-amber-400">"Maybe present"</strong>: If the filter says an item *is* in the set, it *might* be a false positive. It's not 100% certain. This is the trade-off for its speed and low memory use.</li>
                <li>This tool is perfect for quickly checking against massive "block lists" or "allow lists" (e.g., "is this email in our 10-million-user database?") before running a slow, expensive query.</li>
            </ul>
        </div>
    </div>

    <script>
        // --- JAVASCRIPT LOGIC ---

        // --- Bloom Filter Class ---
        // A simple, pure-JS Bloom Filter implementation
        class BloomFilter {
            constructor(size, numHashes) {
                // Use a Uint8Array for memory efficiency.
                // Size is in bits, so we need size/8 bytes.
                this.size = size;
                this.numHashes = numHashes;
                // Create a bit vector, initialized to all 0s
                this.bitVector = new Uint8Array(Math.ceil(size / 8));
            }

            // Simple hash functions (djb2 and sdbm)
            // In a real app, we'd use k different seeds or better hashes (like Murmur3)
            _hash(str, seed) {
                if (seed === 1) { // djb2
                    let hash = 5381;
                    for (let i = 0; i < str.length; i++) {
                        hash = (hash * 33) ^ str.charCodeAt(i);
                    }
                    return (hash & 0x7FFFFFFF) % this.size; // Ensure positive 32-bit int
                }
                if (seed === 2) { // sdbm
                    let hash = 0;
                    for (let i = 0; i < str.length; i++) {
                        hash = str.charCodeAt(i) + (hash << 6) + (hash << 16) - hash;
                    }
                    return (hash & 0x7FFFFFFF) % this.size; // Ensure positive 32-bit int
                }
                // Fallback for more hashes: combine the two
                return (this._hash(str, 1) + seed * this._hash(str, 2)) % this.size;
            }

            // Get all k hash positions for an item
            _getHashPositions(item) {
                const positions = [];
                for (let i = 1; i <= this.numHashes; i++) {
                    positions.push(this._hash(item, i));
                }
                return positions;
            }

            // Set a bit in the bit vector
            _setBit(position) {
                const byteIndex = Math.floor(position / 8);
                const bitIndex = position % 8;
                this.bitVector[byteIndex] |= (1 << bitIndex);
            }

            // Check if a bit is set
            _getBit(position) {
                const byteIndex = Math.floor(position / 8);
                const bitIndex = position % 8;
                return (this.bitVector[byteIndex] & (1 << bitIndex)) !== 0;
            }

            // Add an item to the filter
            add(item) {
                const positions = this._getHashPositions(item);
                positions.forEach(position => {
                    this._setBit(position);
                });
            }

            // Test if an item is in the filter
            test(item) {
                const positions = this._getHashPositions(item);
                for (const position of positions) {
                    if (!this._getBit(position)) {
                        return false; // Definitely not present
                    }
                }
                return true; // Maybe present
            }
        }

        // --- Global State ---
        let fileHeaders = [];
        let fileData = []; // This will hold the full dataset for linear search
        let columnData = []; // This holds only the data from the selected column
        let bloomFilter = null;
        let vizBits = 400; // Number of bits to show in the visualization

        // --- DOM Elements ---
        const fileUpload = document.getElementById('fileUpload');
        const columnSelect = document.getElementById('columnSelect');
        const buildButton = document.getElementById('buildButton');
        const loadingIndicator = document.getElementById('loadingIndicator');
        
        const querySection = document.getElementById('querySection');
        const queryInput = document.getElementById('queryInput');
        const queryButton = document.getElementById('queryButton');
        
        const resultsSection = document.getElementById('resultsSection');
        const queryResultMsg = document.getElementById('queryResultMsg');
        const bloomTime = document.getElementById('bloomTime');
        const linearTime = document.getElementById('linearTime');
        
        const bitArrayViz = document.getElementById('bitArrayViz');
        
        const statItems = document.getElementById('statItems');
        const statSize = document.getElementById('statSize');
        const statHashes = document.getElementById('statHashes');
        const statFPR = document.getElementById('statFPR');
        const statMemory = document.getElementById('statMemory');
        const statOriginalMemory = document.getElementById('statOriginalMemory');


        // --- Initialization ---
        function initViz() {
            bitArrayViz.innerHTML = '';
            for (let i = 0; i < vizBits; i++) {
                const bit = document.createElement('div');
                bit.className = 'bit';
                bit.id = `bit-${i}`;
                bitArrayViz.appendChild(bit);
            }
        }
        initViz();

        // --- Event Listeners ---

        // 1. File Upload
        fileUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const text = event.target.result;
                const lines = text.split('\n').filter(line => line.trim() !== ''); // Split by line, remove empty lines
                
                if (lines.length < 1) {
                    alert("Error: File is empty or invalid.");
                    return;
                }
                
                // Parse Headers
                fileHeaders = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                
                // Parse Data
                fileData = lines.slice(1).map(line => line.split(',').map(h => h.trim().replace(/"/g, '')));

                // Populate column selector
                columnSelect.innerHTML = '';
                fileHeaders.forEach((header, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = header;
                    columnSelect.appendChild(option);
                });

                columnSelect.disabled = false;
                buildButton.disabled = false;
            };
            
            reader.onerror = () => {
                alert('Error reading file.');
                console.error("FileReader error");
            };

            reader.readAsText(file);
        });

        // 2. Build Filter
        buildButton.addEventListener('click', () => {
            const columnIndex = parseInt(columnSelect.value);
            if (isNaN(columnIndex)) {
                alert("Please select a valid column.");
                return;
            }

            // Show loading
            loadingIndicator.classList.remove('hidden');
            loadingIndicator.classList.add('flex');
            buildButton.disabled = true;

            // Use setTimeout to allow UI to update before heavy processing
            setTimeout(() => {
                // Extract unique data from the selected column
                const data = new Set(fileData.map(row => row[columnIndex]).filter(Boolean)); // Use Set for unique items, filter out empty
                columnData = Array.from(data);
                
                const n = columnData.length;
                if (n === 0) {
                    alert("No data found in selected column.");
                    loadingIndicator.classList.add('hidden');
                    buildButton.disabled = false;
                    return;
                }

                // --- Calculate Optimal Bloom Filter Parameters ---
                // We'll aim for a false positive rate (p) of ~1%
                const p = 0.01;
                // m = - (n * ln(p)) / (ln(2)^2)  (size in bits)
                const m = Math.ceil(- (n * Math.log(p)) / (Math.LN2 ** 2));
                // k = (m / n) * ln(2) (number of hash functions)
                const k = Math.round((m / n) * Math.LN2);

                // Create and build the filter
                bloomFilter = new BloomFilter(m, k);
                
                // Reset viz
                initViz(); 
                
                // Add items and update visualization (batched)
                const vizUpdateBatch = Math.ceil(n / 100); // Update viz 100 times
                for (let i = 0; i < n; i++) {
                    const item = columnData[i];
                    bloomFilter.add(item);
                    
                    // Update visualization for a sample of bits
                    if (i % vizUpdateBatch === 0 || i === n - 1) {
                        const positions = bloomFilter._getHashPositions(item);
                        positions.forEach(pos => {
                            if (pos < vizBits) { // Only update if bit is in our visible sample
                                const bitEl = document.getElementById(`bit-${pos}`);
                                if(bitEl) bitEl.classList.add('on');
                            }
                        });
                    }
                }
                
                // Calculate memory usage
                const originalSize = new Blob([JSON.stringify(columnData)]).size;
                const filterSize = bloomFilter.bitVector.byteLength;

                // Update Stats Card
                statItems.textContent = n.toLocaleString();
                statSize.textContent = m.toLocaleString();
                statHashes.textContent = k;
                statFPR.textContent = (p * 100).toFixed(2) + '%';
                statMemory.textContent = (filterSize / 1024).toFixed(2) + ' KB';
                statOriginalMemory.textContent = (originalSize / 1024).toFixed(2) + ' KB';

                // Enable query section
                querySection.classList.remove('opacity-50', 'pointer-events-none');
                loadingIndicator.classList.add('hidden');
                buildButton.disabled = false;

                console.log(`Bloom Filter built: n=${n}, m=${m}, k=${k}`);
            }, 50); // 50ms delay
        });

        // 3. Query
        queryButton.addEventListener('click', () => {
            const query = queryInput.value;
            if (!query || !bloomFilter) return;

            // --- Reset Visuals ---
            document.querySelectorAll('.bit.highlight').forEach(b => b.classList.remove('highlight'));
            resultsSection.classList.remove('hidden');

            // --- 1. Bloom Filter Check ---
            let t0 = performance.now();
            const exists = bloomFilter.test(query);
            let t1 = performance.now();
            
            const bloomResultTime = (t1 - t0);
            bloomTime.textContent = `${bloomResultTime.toFixed(4)} ms`;
            
            // Highlight bits used in the query
            const positions = bloomFilter._getHashPositions(query);
            positions.forEach(pos => {
                if (pos < vizBits) {
                    const bitEl = document.getElementById(`bit-${pos}`);
                    if(bitEl) bitEl.classList.add('highlight');
                }
            });

            // --- 2. Linear Search Check ---
            t0 = performance.now();
            const actualExists = columnData.includes(query);
            t1 = performance.now();
            
            const linearResultTime = (t1 - t0);
            linearTime.textContent = `${linearResultTime.toFixed(4)} ms`;
            
            // --- 3. Display Results ---
            if (exists) {
                // "Maybe present"
                queryResultMsg.innerHTML = `<strong class="text-amber-400">"Maybe present"</strong> <br> The Bloom filter thinks this item is in the set.`;
                queryResultMsg.className = 'text-lg p-4 rounded-lg my-4 bg-amber-900/50 border border-amber-700 text-amber-300';
                
                if (!actualExists) {
                     queryResultMsg.innerHTML += ` <br><strong class="text-red-400">(This was a False Positive!)</strong>`;
                } else {
                     queryResultMsg.innerHTML += ` <br><strong class="text-green-400">(Verified: Item is present)</strong>`;
                }

            } else {
                // "Definitely not present"
                queryResultMsg.innerHTML = `<strong class="text-emerald-400">"Definitely NOT present"</strong> <br> The Bloom filter guarantees this item is not in the set.`;
                queryResultMsg.className = 'text-lg p-4 rounded-lg my-4 bg-emerald-900/50 border border-emerald-700 text-emerald-300';
            }
            
            // Show savings
            if (bloomResultTime > 0 && linearResultTime > 0) {
                const speedup = (linearResultTime / bloomResultTime).toFixed(0);
                if (speedup > 1) {
                    bloomTime.textContent += ` (${speedup}x faster!)`;
                }
            }
        });
        
    </script>
</body>
</html>
